# Verification of Omega Regular Properties

Given a simple system S without blocking states together with the labeling map L and w-regular property P, we need to determine: does S satisfies P hold?

Construct an NBA A for bad behaviors; this means that the language characterized by A is complement of the original regular property P; Lw(A) = (2^AP)w \ P (excluding P)

Check whether L(B(S)) (the set of all words generated by the system) intersection with the language of A (all the bad behaviors) is empty. If the set is empty, S does satisfy the original safety property P.

Since these sets are infinite, we cannot simply construct these sets and take their intersection. So, we will take the product of the system S and the NBA A and check whether the product does satisfy "acceptance condition of A is violated."

This is the same as checking S product A = "almost forever no final state of A"

In order for a word to be accepted by A, the accepting state needs to be visited infinitely often.

Checking omega regular properties requires techniques for checking **persistence properties** in finite systems, in this case on the product of S and A. P is called a persistence property if there exists a propositional formula phi over AP such that P = set of all infinite words over the alphabet (2^AP)^w in which all but finitely many indices Ai satisfies phi.

This is the same as saying "from some moment on phi is true always" or "eventually forever phi is true"

If the persistent property holds, S satisfies P.

## Product of a System and an NBA

Same as for product of S and NFA

## Persistence Checking via Strongly Connected Component

Given a finite simple system S without terminal state and persistence condition a subset of AP, does S satisfies "eventually forever a" hold?

This property DOES NOT hold if any of the following are true:

- There is a state path where we don't eventually end up in a infinitely often
- There is a reachable state s that is not a that has a cycle s...s
- There is a nontrivial reachable (from the initial state) strongly connected component c such that the intersection of c and s (all states that are not a) is non-empty

All of the above statements assume S is finite

A **strongly-connected component (SCC)** is a maximal set of states that are reachable from each other. An SCC is called non-trivial if it has at least one edge: Either 1 state with a self-loop or 2 or more states.

Several well-established, fast algorithms to search for SCCs:

- Kosaraju's algorithm
- Tarjan's SCC algorithm
- Path-based strong component algorithm